// scripts/generate-article-index.mjs
import fs from 'node:fs';
import path from 'node:path';
import fg from 'fast-glob';
import matter from 'gray-matter';
// import { generateReadingTime } from '../lib/helpers.ts';
import readingTime from 'reading-time';

/** Directory containing your MDX articles */
const ROOT = process.cwd();
const POSTS_DIR = path.join(ROOT, 'src', 'data', 'articles');
/** Where to write outputs */
const OUT_JSON = path.join(POSTS_DIR, 'index.json');
const OUT_TS = path.join(POSTS_DIR, 'index.ts');

/** Simple slug from filename (without extension) */
function slugFromFile(filepath) {
  const base = path.basename(filepath).replace(/\.mdx?$/, '');
  return base.toLowerCase();
}

/** Validate and normalize frontmatter for your schema */
function normalizeFrontmatter(data, relFile) {
  const errors = [];
  const title = data.title ?? slugFromFile(relFile);
  if (!data.title) errors.push('title');

  const date = data.date ?? '1970-01-01';
  if (!data.date) errors.push('date');

  const slug = (data.slug ?? slugFromFile(relFile)).toString();

  if (errors.length) {
    console.warn(
      `\n[article index] Missing required frontmatter (${errors.join(', ')}) in: ${relFile}`,
    );
  }

  return {
    slug,
    title,
    date,
    author: data.author ?? null,
    summary: data.summary ?? '',
    tags: Array.isArray(data.tags) ? data.tags : data.tags ? [String(data.tags)] : [],
    articleType: data.articleType ?? null,
    solutionName: data.solutionName ?? null,
    solutionLink: data.solutionLink ?? null,
    coverImage: data.coverImage ?? null,
  };
}

/** Sort newest first (date string or Date accepted) */
function sortByDateDesc(a, b) {
  return new Date(b.date).getTime() - new Date(a.date).getTime();
}

async function main() {
  const files = await fg('**/*.mdx', { cwd: POSTS_DIR, absolute: true, dot: false });

  const entries = files.map((absPath) => {
    const raw = fs.readFileSync(absPath, 'utf8');
    const { data, content } = matter(raw);
    const relPathFromRoot = path.relative(ROOT, absPath).split(path.sep).join('/');

    const fm = normalizeFrontmatter(data, relPathFromRoot);

    // compute reading time (round up)
    const rt = readingTime(content);
    const readTime = `${Math.max(1, Math.round(rt.minutes))} min`;

    return {
      ...fm,
      readTime,
      file: relPathFromRoot,
      url: `/articles/${fm.slug}`,
    };
  });

  // Detect duplicate slugs
  const seen = new Map();
  for (const e of entries) {
    if (seen.has(e.slug)) {
      console.warn(
        `[article index] Duplicate slug "${e.slug}" in:\n- ${seen.get(e.slug)}\n- ${e.file}`,
      );
    } else {
      seen.set(e.slug, e.file);
    }
  }

  // Sort by date (newest first)
  const sortedEntries = entries.sort(sortByDateDesc);

  // Write JSON
  fs.writeFileSync(OUT_JSON, JSON.stringify(sortedEntries, null, 2), 'utf8');

  // Write TS helper
  const ts = `/* Auto-generated by scripts/generate-article-index.mjs */
export type ArticleMeta = {
  slug: string;
  title: string;
  date: string; // ISO
  author: string | null;
  summary: string;
  tags: string[];
  articleType: string | null;
  solutionName: string | null;
  solutionLink: string | null;
  coverImage: string;
  readTime: string;
  file: string;
  url: string;
};

export const articles: ArticleMeta[] = ${JSON.stringify(sortedEntries, null, 2)};


/** Dynamic import map to get the MDX component on demand */
export const loaders: Record<string, () => Promise<any>> = {
${sortedEntries
  // FIX: compute relative path from index.ts to article file
  .map((e) => {
    const relativeImportPath = './' + path.basename(e.file); // each .mdx is in same folder
    return `  "${e.slug}": () => import(${JSON.stringify(relativeImportPath)})`;
  })
  .join(',\n')}
};
`;
  fs.writeFileSync(OUT_TS, ts, 'utf8');

  console.log(
    `[article index] Wrote ${sortedEntries.length} articles â†’\n- ${path.relative(
      ROOT,
      OUT_JSON,
    )}\n- ${path.relative(ROOT, OUT_TS)}`,
  );
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
